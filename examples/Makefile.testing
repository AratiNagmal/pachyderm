.PHONY:

# This makefile is for creating clusters filled with repos and pipelines for end-to-end and functional testing.
# It builds on targets in the main Makefile.  You would invoke it like this
# cd <source-location>/examples ;  make -s -f Makefile.testing dirty-testing-cluster
# That target, "dirty-testing-cluster" is the first workhorse testing target that's been developed.
# It will create a cluster that has failed jobs, failed commmits, and deleted commits.
# Invoking it with "-s" will produce terse, informative output on the steps it's taking to create the
# cluster as it's working.  You might want to run a "watch -n 2 kubectl get pods" and a
# "watch -n 2 pachctl list job" in other windows so you can understand what's happening as it runs.
# At the end, it will print a message telling you the cluster is ready for your testing, and you
# can use it to test extract/restore or for whatever other testing purposes you want.
# There are some top-level functions defined, like pipeline-status and wait-for-jobs, that make it easier
# to write targets that methodically create a cluster that's useful for testing.
# The executable paths below are for macOS.  A future revision will set them correctly for other target OS's.
# Modify them for your system by setting environment variables, using a command like this
# env PACHCTL=./pachctl  make -e  -f Makefile.testing dirty-testing-cluster 

include Makefile

CP := /bin/cp
DOCKER := /usr/local/bin/docker
ECHO := /usr/local/opt/coreutils/libexec/gnubin/echo
JQ := /usr/local/bin/jq
JQFLAGS :=
KUBECTL := /usr/local/bin/kubectl
PACHCTL := /usr/local/bin/pachctl
RM := /bin/rm
SLEEP := /bin/sleep
SORT := /usr/bin/sort
TOUCH := /usr/bin/touch
UNIQ  := /usr/bin/uniq
WC := /usr/bin/wc

STATS := .enable_stats=true
DETECTMODEL := .pipeline.name="object-detect"|.input.cross[1].pfs.repo="object-model"|.input.cross[1].pfs.name="model"
DETECTIMAGES := .input.cross[0].pfs.repo="object-images"|.input.cross[0].pfs.name="images"
HYPERPSPLIT := .input.cross[0].pfs.repo="hp-split"|.input.cross[0].pfs.name="split"
HYPERPMODEL := .input.cross[1].pfs.repo="hp-model"|.input.cross[1].pfs.name="model"
HYPERPTEST := .input.cross[0].pfs.repo="hp-test"|.input.cross[0].pfs.name="test"

# pipeline-status will wait until all pipelines report "Ready"
# takes 0 arguments
# Why so complicated?  Todo: explain that and * usage for items
pipeline-status = $$(CURRENT_STATUS=`$(KUBECTL) get pod -l suite=pachyderm,pipelineName=$(1) \
			-o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}'` ; \
			if [ $$CURRENT_STATUS ] ; then $(ECHO) -n $$CURRENT_STATUS ; else $(ECHO) -n False ; fi)

# wait-for-jobs will wait until there are no pachyderm jobs matching a jq filter condition
# It takes 2 arguments.
# $(1) the jq search filter: the filter '.state!="JOB_SUCCESS"' (without single quotes) will wait until all jobs are successful
#                            the filter '.state!="JOB_SUCCESS" and .state!="JOB_FAILURE" will wait until all jobs have
#                               either succeeded or failed.
#                            You can put any jq filter in her that will work with the --raw output of list job to produce
#                               a list of job id's.
# $(2) description: some text that will inform the user what kind of jobs are done.
wait-for-jobs = while JOBS=`$(PACHCTL) list job --raw | $(JQ) 'select($(1))|.job.id'` && \
			NUMJOBS=`$(ECHO) -n $${JOBS} | $(WC) -w` && \
			[ $${NUMJOBS} -gt 0 ] ; \
		do \
			WHEEL=$${WHEEL:1}$${WHEEL:0:1}; \
			if [ $${NUMJOBS} -gt 1 ] ; \
			then STATUS_MSG="waiting for $${NUMJOBS// } jobs to finish..." ; \
			else STATUS_MSG="waiting for $${JOBS} job to finish..." ; \
			fi ; \
			$(ECHO)  -en "\e[G\e[K$${WHEEL:0:1}$${STATUS_MSG}"; \
			$(SLEEP) 1; \
		done ; \
		$(ECHO) -e "\e[G\e[K$${WHEEL:0:1}$(2) jobs done."

opencv-testing: 
	$(PACHCTL) create repo images
	$(JQ) "$(STATS)" opencv/edges.json | $(PACHCTL) create pipeline -f - >/dev/null
	$(JQ) "$(STATS)" opencv/montage.json | $(PACHCTL) create pipeline -f - >/dev/null
	$(PACHCTL) start transaction
	$(PACHCTL) start commit images@master
	$(PACHCTL) finish transaction
	$(PACHCTL) put file images@master -i opencv/images.txt
	$(PACHCTL) put file images@master -i opencv/images2.txt
	$(PACHCTL) put file images@master -i opencv/images3.txt
	$(PACHCTL) put file images@master -i opencv/images4.txt
	$(PACHCTL) delete file images@master:/w7RVTsv.jpg
	$(PACHCTL) finish commit images@master

opencv-testing-delete:
	-$(PACHCTL) delete pipeline montage
	-$(PACHCTL) delete pipeline edges


object-detection-testing-base: OBJECT_IMAGES = $(ECHO) "object-detection will be using opencv's images repo"
object-detection-testing-base: OBJECT_MODEL_PIPELINE = $(JQ) '$(STATS)|.pipeline.name="object-model"'  ml/object-detection/model.json | $(PACHCTL) create pipeline -f - >/dev/null
object-detection-testing-base: OBJECT_DETECT_PIPELINE = $(JQ) '$(STATS)|$(DETECTMODEL)'  ml/object-detection/detect.json | $(PACHCTL) create pipeline -f - >/dev/null
object-detection-testing-base:  object-detection-base

object-detection-testing: object-detection-testing-base
	$(PACHCTL) put file images@master:airplane.jpg -f ml/object-detection/images/airplane.jpg

object-detection-testing-delete:
	-$(PACHCTL) delete pipeline object-detect
	-$(PACHCTL) delete pipeline object-model
	-$(PACHCTL) delete repo training

opencv-object-detection-testing: opencv-testing object-detection-testing
opencv-object-detection-testing-delete: object-detection-testing-delete opencv-delete

hyperparameter-testing-base: hyperparameter-common
	$(JQ) '$(STATS)|.pipeline.name="hp-split"' ml/hyperparameter/split.json | $(PACHCTL) create pipeline -f - >/dev/null
	$(JQ) '$(STATS)|.pipeline.name="hp-model"' ml/hyperparameter/model.json | $(PACHCTL) create pipeline -f - >/dev/null
	$(JQ) '$(STATS)|.pipeline.name="hp-test"|$(HYPERPSPLIT)|$(HYPERPMODEL)' ml/hyperparameter/test.json | $(PACHCTL) create pipeline -f - >/dev/null
	$(JQ) '$(STATS)|.pipeline.name="hp-select"|$(HYPERPTEST)|$(HYPERPMODEL)'  ml/hyperparameter/select.json | $(PACHCTL) create pipeline -f - >/dev/null

hyperparameter-testing: hyperparameter-testing-base hyperparameter-data

hyperparameter-testing-delete:
	-$(PACHCTL) delete pipeline hp-select
	-$(PACHCTL) delete pipeline hp-test
	-$(PACHCTL) delete pipeline hp-split
	-$(PACHCTL) delete pipeline hp-model
	-$(PACHCTL) delete repo parameters
	-$(PACHCTL) delete repo raw_data

gatk-testing: gatk
	$(PACHCTL) start commit samples@master
	$(PACHCTL) put file samples@master:son/son.bam -f gatk/GATK_Germline/data/bams/son.bam
	$(PACHCTL) put file samples@master:son/son.bai -f gatk/GATK_Germline/data/bams/son.bai	
	$(PACHCTL) finish commit samples@master

gatk-testing-delete: gatk-delete

testing-delete: gatk-testing-delete hyperparameter-testing-delete object-detection-testing-delete opencv-testing-delete
	-$(PACHCTL) delete repo images

testing: opencv-testing object-detection-testing hyperparameter-testing gatk-testing

dirty-testing-cluster: opencv-base  ml/object-detection/frozen_inference_graph.pb object-detection-testing-base hyperparameter-testing-base  $(GATK_GERMLINE_FILES) gatk-base
	until $(call pipeline-status,edges) = True && \
		$(call pipeline-status,montage) = True && \
		$(call pipeline-status,object-model) = True && \
		$(call pipeline-status,object-detect) = True && \
		$(call pipeline-status,hp-split) = True && \
		$(call pipeline-status,hp-model) = True && \
		$(call pipeline-status,hp-test) = True && \
		$(call pipeline-status,hp-select) = True && \
		$(call pipeline-status,joint_call) = True && \
		$(call pipeline-status,likelihoods) = True ; \
	do \
		WHEEL=$${WHEEL:1}$${WHEEL:0:1}; \
		$(ECHO)  -en "\e[G\e[K$${WHEEL:0:1}waiting for pipelines to start..."; \
		$(SLEEP) 1; \
	done
	@$(ECHO) -e "\e[G\e[K$${WHEEL:0:1}pipelines started...";
	$(PACHCTL) start transaction > /dev/null
	$(PACHCTL) start commit images@master > /dev/null 2>/dev/null
	$(PACHCTL) start commit training@master > /dev/null 2>/dev/null
	$(PACHCTL) finish transaction > /dev/null
	$(PACHCTL) put file training@master:frozen_inference_graph.pb -f ml/object-detection/frozen_inference_graph.pb 
	$(PACHCTL) put file images@master:airplane.jpg -f ml/object-detection/images/airplane.jpg 
	$(PACHCTL) put file images@master -i opencv/images.txt 
	$(PACHCTL) put file images@master -i opencv/images2.txt 
	$(PACHCTL) finish commit images@master > /dev/null
	$(PACHCTL) finish commit training@master > /dev/null
	$(call wait-for-jobs,.state!="JOB_SUCCESS",first opencv and object-detection)
	$(ECHO) -e "adding stats to edges and montage..."; 
	$(JQ) "$(STATS)" opencv/edges.json | $(PACHCTL) update pipeline -f - >/dev/null
	$(JQ) "$(STATS)" opencv/montage.json | $(PACHCTL) update pipeline -f - >/dev/null
	@$(ECHO) -e "adding images to images@master that will produce failed jobs...";
	$(PACHCTL) put file images@master -i opencv/images3.txt
	$(call wait-for-jobs,.state!="JOB_SUCCESS" and .state!="JOB_FAILURE",images into images@master that produce object-detection failures)
	@$(ECHO) -e "modifying up object-detection to use new object-images repo and adding images...";
	$(PACHCTL) create repo object-images
	$(JQ) '$(STATS)|$(DETECTMODEL)|$(DETECTIMAGES)' ml/object-detection/detect.json  | $(PACHCTL) update pipeline -f - >/dev/null
	$(PACHCTL) put file images@master -i opencv/images4.txt
	$(PACHCTL) put file object-images@master:dogs.jpg -f ml/object-detection/images/dogs.jpg
	$(PACHCTL) put file object-images@master:airplane.jpg -f ml/object-detection/images/airplane.jpg
	$(call wait-for-jobs,.state!="JOB_SUCCESS",new images in object-images@master and images@master)
	@$(ECHO) -e "adding data to gatk...";
	$(PACHCTL) start transaction > /dev/null
	$(PACHCTL) start commit reference@master > /dev/null 2>/dev/null
	$(PACHCTL) start commit samples@master >/dev/null 2>/dev/null
	$(PACHCTL) finish transaction > /dev/null
	$(PACHCTL) put file reference@master:ref.dict  -f gatk/GATK_Germline/data/ref/ref.dict
	$(PACHCTL) put file reference@master:ref.fasta -f gatk/GATK_Germline/data/ref/ref.fasta
	$(PACHCTL) put file reference@master:ref.fasta.fai -f gatk/GATK_Germline/data/ref/ref.fasta.fai
	$(PACHCTL) put file reference@master:refSDF -r -f gatk/GATK_Germline/data/ref/refSDF
	$(PACHCTL) put file samples@master:mother/mother.bam -f gatk/GATK_Germline/data/bams/mother.bam
	$(PACHCTL) put file samples@master:mother/mother.bai -f gatk/GATK_Germline/data/bams/mother.bai
	$(PACHCTL) finish commit reference@master > /dev/null
	$(PACHCTL) finish commit samples@master > /dev/null
	$(call wait-for-jobs,.state!="JOB_SUCCESS",initial gatk data in references and master)
	if GATK_FATHER_COMMIT=`$(PACHCTL) start commit samples@master` && \
	   [ -n $${GATK_FATHER_COMMIT} ] ; \
	then \
		$(ECHO) -e "adding father to gatk, samples@$${GATK_FATHER_COMMIT} , we will delete..." ; \
		$(PACHCTL) put file samples@master:father/father.bam -f gatk/GATK_Germline/data/bams/father.bam ; \
		$(PACHCTL) put file samples@master:father/father.bai -f gatk/GATK_Germline/data/bams/father.bai ; \
		$(PACHCTL) finish commit samples@master > /dev/null ; \
		GATK_SON_COMMIT=`$(PACHCTL) start commit samples@master` ; \
		$(ECHO) -e "adding son, samples@$${GATK_SON_COMMIT}..." ; \
		$(PACHCTL) put file samples@master:son/son.bam -f gatk/GATK_Germline/data/bams/son.bam ; \
		$(PACHCTL) put file samples@master:son/son.bai -f gatk/GATK_Germline/data/bams/son.bai	; \
		$(PACHCTL) finish commit samples@master > /dev/null ; \
		$(ECHO) -e "deleting father commit, samples@$${GATK_FATHER_COMMIT}..." ; \
		$(PACHCTL) delete commit samples@$${GATK_FATHER_COMMIT} ; \
	else \
		$(ECHO) -e "could not create commit in samples@master..." ; \
	fi
	$(call wait-for-jobs,.state!="JOB_SUCCESS",cluster ready for testing:)





