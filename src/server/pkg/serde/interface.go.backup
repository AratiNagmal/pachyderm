// structfmt is a super-package that contains Pachyderm-specific libraries for
// marshalling and unmarshalling Go structs and maps to structured text formats
// (currently just json and yaml).
//
// Similar to https://github.com/ghodss/yaml, all implementations of the Format
// interface marshal and unmarshal data using the following pipeline:
//
//    Go struct/map (fully structured)
//      <-> JSON document
//      <-> map[string]interface{}
//      <-> target format document
//
// Despite the redundant round of marshalling and unmarshalling, there are two
// main advantages to this approach:
//   - YAML (and any future storage formats) can re-use existing `json:` struct
//     tags
//   - The intermediate map[string]interface{} can be manipulated, making it
//     possible to have flexible converstions between structs and documents. For
//     examples, PPS pipelines may include a full TFJob spec, which is converted
//     to a string and stored in the 'TFJob' field of Pachyderm's
//     CreatePipelineRequest struct.
package serde

type Encoder interface {
	// Marshall converts 'v' (a struct or Go map) to a structured-text document
	// (stored in the returned []byte).
	Encode(v interface{}) ([]byte, error)

	// EncodeTransform is similar to Encode, but users can manipulate the
	// intermediate map[string]interface generated by Format implementations by
	// passing a function. Note that 'Encode(v)' is equivalent to
	// 'EncodeTransform(v, nil)'
	EncodeTransform(v interface{}, f func(map[string]interface{}) error) ([]byte, error)

	// EncodeProto is similar to Encode, but instead of converting between the
	// canonicalized JSON and 'v' using 'encoding/json', it does so using
	// 'gogo/protobuf/jsonpb'.  This allows callers to take advantage of more
	// sophisticated timestamp parsing and such in the 'jsonpb' library.
	//
	// TODO(msteffen): We can *almost* avoid the Encode/EncodeProto split by
	// checking if 'v' implements 'proto.Message', except for one case: the
	// kubernetes client library includes structs that are pseudo-protobufs.
	// Structs in the kubernetes go client implement the 'proto.Message()'
	// interface but are hand-generated and contain embedded structs, which
	// 'jsonpb' can't handle when parsing. If jsonpb is ever extended to be able
	// to parse JSON into embedded structs (even though the protobuf compiler
	// itself never generates such structs) then we could merge this into
	// Encode() and rely on:
	//
	//   if msg, ok := v.(proto.Message); ok {
	//     ... use jsonpb ...
	//   } else {
	//     ... use encoding/json ...
	//   }
	EncodeProto(v interface{}) ([]byte, error)

	// EncodeProtoTransform is similar to EncodeTransform(), but instead of
	// converting between the canonicalized JSON and 'v' using 'encoding/json', it
	// does so using 'gogo/protobuf/jsonpb'.  This allows callers to take
	// advantage of more sophisticated timestamp parsing and such in the 'jsonpb'
	// library.
	//
	// TODO(msteffen) same comment re: proto.Message as for EncodeProto()
	EncodeProtoTransform(v interface{}, f func(map[string]interface{}) error) ([]byte, error)
}

type Decoder interface {
	// Decode parses an underlying stream of text in the given format into 'v'
	// (a struct or Go map)
	Decode(interface{}) error

	// DecodeTransform is similar to Decode, but users can manipulate the
	// intermediate map[string]interface generated by Format implementations by
	// passing a function. Note that 'Encode(v)' is equivalent to
	// 'EncodeTransform(v, nil)'
	DecodeTransform(interface{}, func(map[string]interface{}) error) error

	// DecodeProto is similar to Decode, but instead of converting between
	// the canonicalized JSON and 'v' using 'encoding/json', it does so using
	// 'gogo/protobuf/jsonpb'.  This allows callers to take advantage of more
	// sophisticated timestamp parsing and such in the 'jsonpb' library.
	//
	// TODO(msteffen) same comment re: proto.Message as for
	// Encoder.EncodeProto()
	DecodeProto(interface{}) error

	// DecodeProtoTransform is similar to DecodeTransform, but instead of
	// converting between the canonicalized JSON and 'v' using 'encoding/json', it
	// does so using 'gogo/protobuf/jsonpb'.  This allows callers to take
	// advantage of more sophisticated timestamp parsing and such in the 'jsonpb'
	// library.
	//
	// TODO(msteffen) same comment re: proto.Message as for
	// Encoder.EncodeProto()
	DecodeProtoTransform(interface{}, func(map[string]interface{}) error) error
}
